:toc:

= Nethereum

== What is Nethereum?

Nethereum is the *.Net integration library for Ethereum*, simplifying smart contract management and interaction with Ethereum nodes.

== Blockchain Accounts

In Ethereum, every transaction must be transmitted and signed by an account.
The account must sign in order to authenticate the Ether account holder or the person wishing to communicate with a smart contract. 

=== Use an existing account

You can use any existing account as long as you have your private key. For example you can use https://metamask.io/[Metamask].

In Metamask we can change to the Ropsten Testnet like so:

.Metamask Wallet
image::images/metamask-1.png[]

We can unveil the private key by going to the account details:


image:images/metamask-2.png[]
image:images/metamask-3.png[]

Now that we have our private key we can create the Account in .NET:

[source, c#]
----
var myAccount = new Account(PRIVATE_KEY, Nethereum.Signer.Chain.Ropsten);
----

=== Create an account with Nethereum

As the accounts for the blockchain only consist of a public key and a private key, we can create them using Nethereum library.

[source, c#]
----
var ecKey = EthECKey.GenerateKey();
var privateKey = ecKey.GetPrivateKeyAsBytes().ToHex();
var account = new Account(privateKey, Nethereum.Signer.Chain.Ropsten);
----

== HD Wallets

HD Wallet stands for Hierarchical Deterministic Wallet, a type of wallet that derive an unlimited number of addresses from a single master seed.
Initiating a HD Wallet requires a list of words and a password as arguments:

[source, c#]
----
// Create the list of random words 
var mnemo = new Mnemonic(Wordlist.English, WordCount.Twelve);
	 
// Convert the mnemonic to string
var words = mnemo.ToString();

// Create the instance of the wallet
var wallet = new Wallet(words, password);
----

Now you can create as many accounts as you want and use methods such as:

[source, c#]
----
// Gets a list of the first 10 addresses on the wallet
var addressList = wallet.GetAddresses(10);

// Gets the account in the 3 position
var account = wallet.GetAccount(3);
----

== Connect with Web3 Clients

The interaction with the Ethereum network must be done through a client node that allows sending requests.

There are a lot of public clients that you can use to send this requests to Ethereum. The one that we are going to use is Infura.

For that we will need to go to https://infura.io/[Infura website], and create an account. Once you have your account you will need to add a gate to the network following the next steps:

*Step 1*: Create a new project

.Infura Dashboard
image::images/Infura-1.png[]
image::images/Infura-2.png[]

*Step 2*: Copy the link for your desired network. In our case we will be choosing Ropsten.

.Infura project configuration
image::images/Infura-3.png[]

Now that we have our link to the endpoint and our Ethereum account, we can go to Visual Studio to open a connection to the network like so:

[source, c#]
----
var myAccount = new Account(PRIVATE_KEY, Chain.Ropsten);
var web3 = new Web3(myAccount, $"https://ropsten.infura.io/v3/{YOUR_PROJECT_ID}");
----

== Smart Contracts - Code Generation

Nethereum provides a code generator that lets you to generate.Net classes (C#, Vb.Net, and F#) from smart contract compilation output (ABI and Bin).

Nethereum offers a variety of tools based on the same code creation. 

=== Web based code generation

The Web based code generation https://codegen.nethereum.com[Nethereum Playground] is a simple online tool, to code generate a smart contract definition without the need to install any tools. Just input your Abi, Bytecode, Smart contract name and Namespace.

=== VsCode Solidity extension integrated code generation

*Prerequisites*:

. Visual Studio Code
. https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity[Solidity vscode extension].
. A solidity smart contract

NOTE: For more information about environment please refer to the link:Blockchain-environment.asciidoc[Environment documentation]

*Steps*:

.	Create a settings file (call it `nethereum-gen.settings`) into your working directory, this directory will need to have your solidity contracts
+
This file can be also autogenerated, select your contract and press F1(1), write _“Solidity Create `nethereum-gen.settings`”_(2), and select the option(3) as shown in the following image:
+
image::images/Nethereum-1.png[]
+
Your nethereum-gen.settings file should look like this:
+
image::images/Nethereum-2.png[]
+
Where:

* *projectName*: The name of the project that will be created.
* *namespace*: Is the namespace of the generated files.
* *lang*: Indicates what language to generate the code, 0 = CSharp, 1 = Vb.Net and 3 = FSharp.
* *projectPath*: Relative path of your .Net project.


. Compile the contracts, for that you must select the contract press F1(1), write _“Solidity Compile and Code generate CSharp”_ and select the option(3) as the following picture:
+
image::images/Nethereum-3.png[]
+
You should now see a newly generated bin folder(1), the project folder(2), and the .csproj file(3):
+
image::images/Nethereum-4.png[]

. Now you can add to your .Net solution the autogenerated project.

=== Nugget autocode generation

Nethereum offers a code generator which allows you to generate dotnet classes from the ABI and Bin output of the compilation of Solidity contracts.

*Prerequisites*:

. Visual Studio and Visual Studio Code.
. https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity[Solidity vscode extension].
. A solidity Smart Contract.
. Dotnet Core 2.1 must be installed on the machine. The code generator runs on Dotnet Core 2.1, BUT your target project does not need to be a Dotnet core project.

NOTE: For more information about environment please refer to the link:Blockchain-environment.asciidoc[Environment documentation]

*Steps*:

. Compile your Solidity contracts, for that you must select the contract press F1(1), write _“Solidity Compile”_ and select one of the options(3) as the following picture:
+
image::images/Nethereum-5.png[]
+
Your working directory should look like this after compiling:
+
image::images/Nethereum-6.png[]

. Create a .Net project or use your desired one in Visual Studio.

. Paste your .abi and .bin files from the previous step in the project. They can be at the root of the project or in any sub folder of the project.
+
image::images/Nethereum-7.png[]
+
WARNING: .bin files should have the same name as .abi e.g. `StandardContract.abi`, `StandardContract.bin`

. Install the nuGet packages, via nuGet package manager
+
image::images/Nethereum-8.png[]
+
or via nuGet package manager console, running the following commands:
+
[source, console]
----
Install-Package Nethereum.Web3
Install-Package Nethereum.Autogen.ContractApi
----

== Smart Contracts - Deployment

To deploy a contract to the network with Nethereum we will need to have generated the code as explained in the previous step. Once we have done that we can deploy the contract using the generated classes:

[source, c#]
----
// Create an instance of the autogenerated deployment class for the contract
var calculatorDeployment = new CalculatorDeployment();
	 
// Get the deployment handler for the type of the contract
var deploymentHandler = Web3.Eth.GetContractDeploymentHandler<CalculatorDeployment>();
 
// Send the transaction
var transactionReceipt = await deploymentHandler.SendRequestAndWaitForReceiptAsync(calculatorDeployment);
 
// Get the contractAddress
var contractAddress = transactionReceipt.ContractAddress;
----

== Smart Contracts - Use

To use the contract we will need the contract address on the blockchain and the classes generated automatically. In the following example, we are using the AddFunction of the calculator contract:

[source, c#]
----
// Create an instance of the autogenerated add function class of the contract
var addFunction = new AddFunction()
{
    A = 10,
    B = 10,
};
	 
// Get Handler for the function 
var addHandler = Web3.Eth.GetContractQueryHandler<AddFunction>();
	 
// Request the result from the contract function
var result = await addHandler.QueryAsync<BigInteger>(ContractAddress, addFunction);
----

== Ether transfer

We can do the following to transfer Ether to another account given its public address.

[source, c#]
----
var web3 = NethereumHelper.GetWeb3Instance();
	 
// Destination address
var toAddress = "0x1FD3c8bA8Bb480cF4B0F8b6d42eE30b04dCFc0B5";
	 
//Check before balance
var beforeBalance = await web3.GetBalance(toAddress);
	 
var transaction = await web3.Eth.GetEtherTransferService()
            .TransferEtherAndWaitForReceiptAsync(toAddress, 0.001m);

//Check after balance
var afterBalance = await web3.GetBalance(toAddress);
----

And for checking the balance of the account we can create the following extension method.

[source, c#]
----
public static async Task<decimal> GetBalance(this Web3 web3, string account)
{
    var result = await web3.Eth.GetBalance.SendRequestAsync(account);
    return Web3.Convert.FromWei(result.Value);
} 
----

== Fee calculation

EIP-1559 changes the calculation method of Ethereum transaction fees and the whereabouts of these fees. It is now necessary to pay attention to three independent values, not a single Gas price.

* The Base Fee, which is determined by the network itself, is subsequently destroyed.

* Max Priority Fee, which is optional, determined by the user, and paid directly to the miner.

* The maximum fee per unit of Gas (*Max Fee Per Gas*), which is the highest absolute value you are willing to pay per unit of Gas to include your transaction in the block. For the sake of brevity, we will call it the maximum cost.

Nethereum provides 3 built in strategies to suggest the 1559 fees:

* *GetSimpleFeeSuggestionStrategy()*-> The simple fee suggestion strategy, gets the base fee * 2 and adds a Default Max Priority Gas of 2 gwei.
+
[source, c#]
----
public static async Task<Fee1559> GetSimpleFee(this Web3 web3)
        {
            var simpleFeeSuggestion = web3.FeeSuggestion.GetSimpleFeeSuggestionStrategy();

            web3.TransactionManager.Fee1559SuggestionStrategy = simpleFeeSuggestion;

            var fee = await simpleFeeSuggestion.SuggestFeeAsync();
            
            return fee;
        }
----

* *GetTimePreferenceFeeSuggestionStrategy()*-> SuggestFee will return a single fee which the first element that corresponds to the highest time preference(most urgent transaction)For example:
+
[source, c#]
----
public static async Task<Fee1559> GetTimePreferenceFee(this Web3 web3)
        {
            var timePreferenceFeeSuggesionStrategy = web3.FeeSuggestion.GeTimePreferenceFeeSuggestionStrategy();

            web3.TransactionManager.Fee1559SuggestionStrategy = timePreferenceFeeSuggesionStrategy;

            var fee = await timePreferenceFeeSuggesionStrategy.SuggestFeeAsync();

            return fee;
        }
----

* *GetMedianPriorityFeeHistorySuggestionStrategy()*-> Suggest a priority fee based on the Fee history of previous blocks and the median of all its values:
+
[source, c#]
----
public static async Task<Fee1559> GetMedianFee(this Web3 web3)
        {
            var medianPriorityFeeSuggestion = web3.FeeSuggestion.GetMedianPriorityFeeHistorySuggestionStrategy();

            web3.TransactionManager.Fee1559SuggestionStrategy = medianPriorityFeeSuggestion;

            var fee = await medianPriorityFeeSuggestion.SuggestFeeAsync();

            return fee;
        }
----

== Message Signature

Nethereum provides methods to sign messages in an Ethereum compatible format. The following is a quick guide to signing a string with Nethereum and verifying a signature using two methods.
In the Ethereum context, signing a message allows us to verify that a piece of data was signed by a specific account, in other terms, it's a way to prove to a smart contract/human that an account approved a message.


=== Signing and verifying

The first method will sign a message and verify the address that signed the message.

[source, c#]
----
// Private key of the signer account address
var privateKey = NethereumHelper.PRIVATE_KEY;
 
// Message to sign
var message = "This is a signed message";
	 
var signer = new EthereumMessageSigner();
	 
// Sign the message and obtain the signature
var signature = signer.EncodeUTF8AndSign(message, new EthECKey(privateKey));
	
// With the message and the signature we recover the public address of the signer
var recoveredAddress = signer.EncodeUTF8AndEcRecover(message, signature);
----

=== Hashing, signing and verifying

In some cases, hashing data and then signing it might be more relevant, i.e. when dealing with a large file.

[source, c#]
----
// Private key of the signer account address
var privateKey = NethereumHelper.PRIVATE_KEY;
	 
// Message to sign
var message = "This is a signed message";
	 
var signer = new EthereumMessageSigner();
	 
// Hash the message, sign it with the private key and obtain the signature
var signature = signer.HashAndSign(message, privateKey);

// With the message and the signature we recover the public address of the signer
var recoveredAddress = signer.HashAndEcRecover(message, signature);

----

== Keystore

A keystore is a JSON-encoded file that contains a single (randomly generated) private key, encrypted by a passphrase for extra security. Keystores are a standard way to store private keys. Nethereum offers a dedicated ‘keystore’ service to facilitate the creation and management of keystore files.

[source, c#]
----
var keyStoreService = new KeyStoreScryptService();
	 
var scryptParams = new ScryptParams { Dklen = 32, N = 262144, R = 1, P = 8 };
	 
var ecKey = new EthECKey(NethereumHelper.PRIVATE_KEY);
var password = "testPassword";
var keyStore = keyStoreService.EncryptAndGenerateKeyStore(password, ecKey.GetPrivateKeyAsBytes(), ecKey.GetPublicAddress(), scryptParams);
var json = keyStoreService.SerializeKeyStoreToJson(keyStore);
var key = keyStoreService.DecryptKeyStoreFromJson(password, json).ToHex();
----