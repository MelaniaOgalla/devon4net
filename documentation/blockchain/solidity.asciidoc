:toc:

= Solidity

Solidity is a high-level, object-oriented language for writing smart contracts. It is based on other programming languages, including C++, Python, and JavaScript. If you're familiar with any of those languages, Solidity code should feel familiar.

Solidity is statically typed, which means that type checking happens at compile time, not at run time like with dynamically typed languages.
It supports inheritance, which means that functions, variables, and other properties present in one contract can be used in another. The language also supports complex user-defined types like structs and enums, which allow you to group related types of data together.

Solidity is an open-source programming language with a growing community of collaborators. To learn more about the Solidity project and how to contribute, see the https://github.com/ethereum/solidity[GitHub repository].

[source, solidity]
----
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.9.0;

contract HelloWorld {
    function helloWorld() external pure returns (string memory) {
        return "Hello, World!";
    }
}
----

The piece of code showed above represents a very simple `HelloWorld.sol` so you can have an overview of what is like to develop in Solidity.


== Smart Contracts

A smart contract is a program that's stored inside a blockchain. Smart contracts extend blockchain from data to code. They represent an agreement between parties. The agreement is coded, and when an action happens, the code runs and provides a response.

Smart contracts run on their own, send events which trigger state transitions, and call functions. They're perfect for blockchain technology because they allow people who don't know one another to do business in a securely specified way that requires no middleman.

Smart contracts have these key properties and advantages:

* *Transparency*: Blockchain users can read smart contracts and can access them by using APIs.
* *Immutability*: Smart contract execution creates logs that can't be changed.
* *Distribution*: The output of the contract is validated and verified by nodes on the network. Contract states can be publicly visible. In some cases, even "private" variables are visible.

=== Ethereum Virtual Machine (EVM)

Ethereum is one of the most popular blockchain platforms, right behind Bitcoin. It's a community-built technology and has its own cryptocurrency called Ether (ETH) that you can buy and sell. On of its main differences is that it is one of the few programmable blockchains. That means that it supports Smart Contract deployment in its networks.

Solidity contracts run on the Ethereum Virtual Machine, or EVM for short. It's a sandboxed environment that is completely isolated. It doesn't access anything else on the network besides the contracts it executes. Solidity smart contracts will be deployed to and run in a virtual environment.

== Solidity Syntax

NOTE: This is only an introduction to the Solidity Syntax, to learn everything about Solidity please visit https://docs.soliditylang.org/[Solidity documentation].

=== Basic concepts

==== Comments

Single-line comments (//) and multi-line comments (/+++*+++...+++*+++/) are possible.

[source, solidity]
----
// This is a single-line comment.

/*
This is a
multi-line comment.
*/
----

==== Pragma directives

The pragma keyword is used to enable certain compiler features or checks. 

Source files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes.

The version pragma is used as follows:

[source, solidity]
----
pragma solidity ^0.5.2;
----

=== Variables

In solidity we have three types of variables:

* *State*: Variables whose values are permanently stored in a contract storage.
+
[source, solidity]
----
pragma solidity >0.7.0 <0.8.0;

contract Example {
    uint data; //This is a state variable
}
----
* *Local*: Variables whose values are available only within a function where it is defined. Function parameters are always local to that function.
+
[source, solidity]
----
pragma solidity >0.7.0 <0.8.0;

contract Example {
    function increment(unit a) public pure returns(uint) {
        uint b = 1; // This is a local variable
        return a + b;
    }
}
----
* *Global*: These are special variables which exist in global workspace and provide information about the blockchain and transaction properties.
+ 
|=====
|*Name* | *Returns*
|blockhash(uint blockNumber) returns (bytes32) | Hash of the given block - only works for 256 most recent, excluding current, blocks
|block.coinbase (address payable) | Current block miner's address
|block.difficulty (uint) | Current block difficulty
|block.gaslimit (uint) | Current block gaslimit
|block.number (uint) | Current block number
|block.timestamp (uint) | Current block timestamp as seconds since unix epoch
|gasleft() returns (uint256) | Remaining gas
|msg.data (bytes calldata) | Complete calldata
|msg.sender (address payable) | Sender of the message (current caller)
|msg.sig (bytes4) | First four bytes of the calldata (function identifier)
|msg.value (uint) | Number of wei sent with the message
|now (uint) | Current block timestamp
|tx.gasprice (uint) | Gas price of the transaction
|tx.origin (address payable) | Sender of the transaction
|=====

=== Functions

Functions describe a single action for achieving one task. They're reusable and can also be called from other source files like libraries. Functions are usually defined inside a contract, but they can also be defined outside of contracts.

[source, solidity]
----
pragma solidity >0.7.0 <0.8.0;

contract Marketplace {
    function buy() public {
    // ...
    }
    function buy(uint price) public returns (uint) {
    // ...
    }
}
----

Additionally, you can specify the visibility of a function variable as: 

* *external*: An external function f cannot be called internally (i.e. `f()` does not work, but `this.f()` works).
* *internal*: Internal functions can only be accessed from within the current contract or contracts deriving from it.
* *public*: Public functions are part of the contract interface and can be either called internally or via message calls.
* *private*: Private functions can only be accesed from the current contract, not 

Other function modifiers that can be used in the function definition are:

* *pure* to describe functions that don't allow modifications or access of state.
* *view* to describe functions that don't allow modifications of state.
* *payable* to describe functions that can receive Ether.

[source, solidity]
----
pragma solidity >=0.4.16 <0.9.0;

contract C {
    uint private data;

    function pureFunction(uint a) private pure returns(uint b) { return a + 1; }
    function viewFunction() public view returns(uint) { return data; }
    function setData(uint a) public { data = a; }
    function internalFunction(uint a, uint b) internal pure returns (uint) { return a + b; }
}
----

Apart from this function modifiers you can create custom modifiers that you can then use to change the behaviour of a function. For example to add a requisite.

[source, solidity]
----
pragma solidity >=0.4.16 <0.9.0;

contract C {
    bool public isLocked;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function f() public unlocked {
        // Only will work when the contract is unlocked by the owner
    }

    function lockContract() public onlyOwner {
        isLocked = true;
    }

    function unlockContract() public onlyOwner {
        isLocked = false;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    // You can apply this modifier to all functions so that the contract can only be used when unlocked
    modifier unlocked {
        require(isLocked == false);
        _;
    }
}
----

== Design Patterns


== Next Steps

=== References

* https://docs.soliditylang.org/[Solidity Documentation]
