:toc:

= How does Blockchain work?

The blockchain is incredibly complicated, and we have already covered the fundamentals in earlier documents. 

After reading the `Introduction to Blockchain` document, you may have questions like: How are transactions verified? How are blocks "mined"? How do nodes communicate and know about other nodes? 

As a result, there are a number of notions that need to be understood in order to start comprehending better how everything works. 

== Transactions

Transactions are the smallest unit to which the blockchain can be reduced. They are interactions that take place on the blockchain and change its state. These transactions are the core of the blockchain, the database that defines the current state of it.

.Simple representation of a transaction
image::images/change_of_state.png[]

In Ethereum these transactions might, for instance, involve a transfer between two accounts or an interaction with a blockchain contract that changes some type of state thus needs to be stored.

The set of all transactions is what forms the distributed ledger that we know today as blockchain.

*But, how do we know who sends the transactions? Can they be hacked?*

Transactions are cryptographically signed instructions from accounts. By using assymetric cryptography, we can sign transactions using a private key and then verify the signature by using a public key. So that whoever owns the key pair is the owner of the transaction.

The owner of a key pair automatically loses control over who can transact or sign documents on their behalf if their private key is exposed.

=== Accounts

An account is made up of a public and a private key. Public key cryptography uses unique keys to secure information. These keys are based on mathematical functions that have a special property: it is very Seasy to calculate them, but hard to calculate their inverse. Based on these functions, cryptography enables the creation of digital secrets and unforgeable digital signatures, which are secured by the laws of mathematics.

For example, multiplying two large prime numbers together is trivial. But given the product of two large primes, it is very difficult to find the prime factors (a problem called prime factorization). Let’s say we present the number 8,018,009 and tell you it is the product of two primes. Finding those two primes is much harder for you than it was for me to multiply them to produce 8,018,009.

A more advanced category of mathematical functions that is useful in cryptography is based on arithmetic operations on an elliptic curve. In elliptic curve arithmetic, multiplication modulo a prime is simple but division (the inverse) is practically impossible. This is called the discrete logarithm problem and there are currently no known trapdoors. Elliptic curve cryptography is used extensively in modern computer systems and is the basis of Ethereum’s (and other cryptocurrencies’) use of private keys and digital signatures.

.Elliptic curve cryptography representation
image::images/ecc_diagram.png[]

=== HD Wallets

"HD Wallet" stands for Hierarchical Deterministic Wallets and they are cryptocurrency wallets that use a single seed of 12, 18 or 24 keywords, with which they can generate an unlimited number of addresses. This is done automatically, hierarchically, and sequentially. However, remembering the seed is somewhat complicated since it is an illegible alphanumeric character string, therefore, the mnemonic codes. They make this seed understandable words for us, so making a backup is much easier and more practical.

This wallets are the most used among all users because they are easy to memorize and produce as much wallets as you want. As they always produce the same wallets, you can import them to any blockchain client that you want to use.

Example of seed phrase:

`witch collapse practice feed shame open despair creek road again ice least`

WARNING: This seed phrase has been generated as an example. *DO NOT USE IT FOR ANY PURPOSE OTHER THAN TESTING!*

== The chain of blocks

Blocks are data structures within the blockchain database, where transaction data in a cryptocurrency blockchain are permanently recorded. A block records some or all of the most recent transactions not yet validated by the network. Once the data are validated, the block is closed. Then, a new block is created for new transactions to be entered into and validated.

A block is thus a permanent store of records that, once written, cannot be altered or removed.

A block stores information. There are many pieces of information included within a block, apart from the list of transactions, that do not occupy too much storage space. Blocks generally include these elements, but it might vary between different blockchains, but what they all include is:

* *Previous block Hash*: The hash operation of the previous block.
* *Block Hash*: The hash operation of the block.
* *Transactions data*: A list of all of the transactions within a block.
* *Nonce*: The encrypted number that a miner must solve to verify the block and close it. (In case of _proof of work_)

.Block content
image::images/block.png[]

=== Why Hashes?

Hashes are the output of a hashing algorithm. These algorithms essentially aim to produce a unique, fixed-length string for any given piece of data.

Hashes are used in blockchain technology because they are easy to compute and can be used to verify that the content of a block has not changed. If something changes inside a block the hash will also change and the chain will break.

=== Blockchain

The blockchain is the succession of all the blocks connected by their hashes forming a chain. It all starts in the `genesis` block, which is the first one and can't be connected to other block. Then the chain starts growing.

.Blockchain first blocks
image::images/blockchain_genesis.png[]

The process of calculating hashes for the new blocks is difficult due to a problem that needs to be solved. Not all the hashes are valid, there is a condition known as "target hash" that needs to be satisfied for the hash to be valid. 

This helps to make impossible for hackers to try modifying the blockchain data. For example, imagine that we want to change something in `block 2` as shown in _Figure 4_. If the data changes, so will do the hash of `block 2`, which we will need to recalculate. This calculation will take a while and we will also need to recalculate all hashes of subsequent blocks. All of this while other blocks are being calculated and added to the chain by all the network power.

This is almost, but not quite, impossible. 

==== 51% Attack

There is a type of attack where one entity controls more than half of the computing power within a blockchain network. This entity would be able to add incorrect blocks into the chain.

The *consensus* algorythm of a blockchain system validates the record with the longest transactional history as we explain further in this document. That means that if a entity owns 51% of network power, they could add an incorrect block and eventually have the longest version of the chain, which will be treated as valid. 

== P2P networks

A peer-to-peer (P2P) network is a computer network in which all or some aspects function without fixed clients or servers, but rather a series of nodes that behave as equals to each other. Furthermore, they act simultaneously as clients and servers with respect to the other nodes of the network. 

Peers make a portion of their resources, such as processing power, disk storage or network bandwidth, directly available to other network participants, without the need for central coordination. Peers are both suppliers and consumers of resources, and are in constant communication with each other.

When a client enters this system, he makes a direct connection to one of the latter, where he collects and stores all the information and content available to share. It is then a program whose function is to connect users through a network without servers that facilitates transfer between nodes. These files are shared "from computer to computer" by the mere fact of having access to the system.

.client-server vs p2p networks
image::images/server_p2p.png[]

Blockchains operate on peer-to-peer networks. As you can see in _Figure 5_ in a client-server, clients communicate with a centralized server. On the other hand, in a peer-to-peer network, all nodes are the same and interact with each other in a decentralized form.

=== Nodes

Blockchain nodes are network stakeholders and their devices that are authorized to keep track of the distributed ledger and serve as communication hubs for various network tasks.  A blockchain node’s primary job is to confirm the legality of each subsequent batch of network transactions, known as blocks.

They are part of the network and serve the following functions:

* Validate the signature of transactions.
* Storing transaction history of all of the blocks that form the blockchain.
* Mine new blocks by solving the problem of calculating a valid hash in exchange for cryptocurrency tokens.
* Propagate new transactions and new blocks to neighbour nodes.
* Arrive to a consensus with the rest of the network.

Although all nodes act the same way in a peer-to-peer network there are different types of nodes that are classified according to its specific characteristics. 

In Bitcoin for example you have two types of nodes. *Full nodes* which store a copy blockchain and thus guarantee the security and correctness of the data on the blockchain by validating data. And *lightweight nodes* which needs to connect to a full node in order to synchronize to the current state of the network and be able to participate.

.Types of nodes in a P2P network
image::images/node_types.png[]

==== Lightweight nodes

These types of nodes communicate with the blockchain while relying on full nodes to provide them with the necessary information. As they don’t store a copy of the chain, they only query the current status for which block is last, and broadcast transactions for processing.

Its purpose is to serve as a door to the network and they don't participate in consensus mechanism.

==== Full Nodes

Full nodes act as a server in a decentralized network. Their main tasks include maintaining the consensus between other nodes and verification of transactions. They also store a copy of the blockchain, thus being more secure and enable custom functions such as instant send and private transactions.

===== Pruned Full Node

One type is the pruned full node. The specific characteristic here is that it begins downloading blocks from the beginning and once it reaches the set limit, deletes the oldest ones, retaining only their headers and chain placement.

===== Archival Full Node

Archival full nodes are what most people refer to when talking about full nodes. They envision a server which hosts the full blockchain in its database. The difference between pruned and archival node is one – the amount of hard drive space they take up.

An archival full node can either be:
 
* *Masternode:*  Masternodes themselves cannot add blocks to the blockchain. Their only purpose is to keep a record of transactions and validate them. By running a masternode, you not only secure the network but can earn a share of the rewards for your services.

* *Mining node (proof-of-work):* Miners are actually nodes which aim to prove that they’ve completed the required work to create a block. Participants in the process employ hardware components to solve a cryptographic problem. The first node to complete the task broadcasts his results to the network so it can be verified. For their work, miners are rewarded a pre-defined amount of coins in addition to any transaction fees for the block.

* *Staking node (proof-of-stake):* In proof of stake the end goal is to determine, based on a pre-defined set of rules and luck chance factored in, who will be next to create a block and get rewarded. Instead of trying to solve a problem, you buy coins and hold them, while in return you receive an interest back as a reward.


* *Authority node (proof-of-authority):* Networks that make use of proof of authority need to define a fixed number of authority nodes. How many and who they’ll be is voted on by the community or defined by the development team. The task of these nodes is, as with full nodes, is to create and validate blocks, while at the same time distributing information to users on the network.

=== Communication

You are already aware that the blockchain relies on peer-to-peer networks, that these networks are composed of nodes, that nodes can take many different forms, and that nodes must perform a variety of tasks depending on their type.

At the end, far from all these abstractions the blockchain is ultimately a network with many parties involved, thus it must adhere to a number of algorithms and communication protocols in order to operate properly. 

For the many tasks it has to do, each blockchain network uses a particular set of protocols and algorithms. Some are better in security and others more eficient but they all address the same issues, among which are:

* *Communication protocol:* Network protocol used from node-to-node communication.

* *Discovery process:* When a new node is added to the network it needs a form of connecting to its neighbours. The discovery process is the process a node follows to discover and connect to its neighbours so that the network can continue growing. 

* *Consensus algorithm:* Process used to reach an agreement throughout all the nodes in the network.


In *Bitcoin* for example the communication relies on the _TCP protocol_ and the discovery process starts by the new node connecting to a DNS Server. This server provides a form of connection to one of the nodes, which then provides the new node with all of its neighbours. This process is shown in the animation below.

.Discovery process in Bitcoin
image::images/communication_bitcoin.gif[]

On the other hand *Ethereum* relies on the _RLPx protocol suite_, which uses other protocols such as Kademlia and UDP. 

Ethereum has some nodes in the network called "boot nodes" whose directions for connection are hard-coded in the blockchain implementation. For the discovery process, the new node connects to the boot nodes and asks them for neighbour nodes connections. Once the process is finished, it closes the connection with the boot nodes to let other new nodes connect to them.

.Discovery process in Ethereum
image::images/communication_ethereum.gif[]

== Validation and consensus

In this part we are going to follow the process of adding a new transaction and mining a block.

As we explained above, the transaction validation is done by signing transactions with a key using asymmetric cryptography. An opposite process helps to verify the origin of the signature and thus verify that everything has been done correctly and it is not a ghost transaction.

First of all, to add a transaction to the blockchain we must have access to the network, for that we need to own a node or have access to a client such as https://infura.io/[Infura].

When a new transaction is added, this transaction is stored in a temporary list of transactions that will be added to the block when its mined. This transaction needs to be verified and propagated to the rest of the network so that whoever mines the block, can add the transaction to it.

.Transaction propagation
image::images/transaction_propagation.gif[]

The previous figure shows how the transaction is verified by all of the nodes and then propagated to them neighbours until the whole network knows about the transaction.

While transactions are being added to this temporary list, the nodes are also calculating a hash that satisfies the condition. For example, we can have the following condition:

    Find a number x such as that the hash of x appended to the block hash results is a number less than the target hash.

`X` will be the nonce, which is a number incremented randomly or progressively that at some point will produce a valid hash. Once the hash is calculated all the data is locked into the block, verified and then propagated to the neighbours.

But, since this process is done simultaneously on all nodes, *what happens if two nodes mine the same block at the same time?*

Well, that will produce two different forks on the blockchainn as shown in the following figure:

.Forks produced by simultaneous mining
image::images/forks.gif[]

This is a pretty common situation and will eventually be solved when a block in one of the two branches mines the next block. 

`The most correct version of the blockchain is the longest valid chain (the one that has more blocks that can be verified).`

Looking at the previous animation example, we can see that there are two branches, each being 7 blocks long. As both have the same number of valid blocks, each branch continues on its way until a node mines block number 8.  Then, as can be seen in figure 11, this will be the "most correct" blockchain, and it will spread to the rest of the network.

.Applied consensus
image::images/consensus.gif[]

The other chains will no longer live in the database and are discarded.

== Next Steps
=== References



